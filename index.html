<div id="viblyApp">
    <!-- Header with logo and navigation -->
    <header id="headerEl" style="background: linear-gradient(135deg, #ffffff, #9370DB); padding: 20px; box-shadow: 0 2px 10px rgba(0,0,0,0.1);">
      <h1 style="margin: 0; color: #6a0dad; font-size: 2.5em; font-weight: bold;">Vibly</h1>
      <p style="margin: 5px 0 20px; color: #666;">Connect and share your vibe</p>
      
      <div id="navButtonsCtn" style="display: flex; justify-content: center; gap: 10px;">
        <button id="homeBtn" class="nav-btn active" style="background: #6a0dad; color: white; border: none; padding: 10px 20px; border-radius: 20px; cursor: pointer;">Home</button>
        <button id="profileBtn" class="nav-btn" style="background: white; color: #6a0dad; border: 1px solid #6a0dad; padding: 10px 20px; border-radius: 20px; cursor: pointer;">Profile</button>
        <button id="premiumBtn" class="nav-btn" style="background: white; color: #6a0dad; border: 1px solid #6a0dad; padding: 10px 20px; border-radius: 20px; cursor: pointer;">Premium</button>
        <button id="logoutBtn" class="nav-btn" style="background: white; color: #6a0dad; border: 1px solid #6a0dad; padding: 10px 20px; border-radius: 20px; cursor: pointer;">Logout</button>
      </div>
    </header>
  
    <!-- Auth section (login/register) -->
    <section id="authSectionCtn" style="max-width: 400px; margin: 50px auto; padding: 20px; background: white; border-radius: 10px; box-shadow: 0 0 20px rgba(0,0,0,0.1);">
      <div id="loginFormCtn">
        <h2 style="color: #6a0dad;">Login to Vibly</h2>
        <input id="loginUsernameInput" type="text" placeholder="Username" style="width: 100%; padding: 10px; margin-bottom: 10px; border: 1px solid #ddd; border-radius: 5px;">
        <input id="loginPasswordInput" type="password" placeholder="Password" style="width: 100%; padding: 10px; margin-bottom: 10px; border: 1px solid #ddd; border-radius: 5px;">
        <button id="loginBtn" style="width: 100%; background: #6a0dad; color: white; padding: 12px; border: none; border-radius: 5px; cursor: pointer; font-weight: bold;">Login</button>
        <p style="margin-top: 20px; text-align: center;">Don't have an account? <a href="#" id="showRegisterBtn" style="color: #6a0dad; text-decoration: none;">Register</a></p>
      </div>
      
      <div id="registerFormCtn" hidden>
        <h2 style="color: #6a0dad;">Create an Account</h2>
        <input id="registerUsernameInput" type="text" placeholder="Username" style="width: 100%; padding: 10px; margin-bottom: 10px; border: 1px solid #ddd; border-radius: 5px;">
        <input id="registerPasswordInput" type="password" placeholder="Password" style="width: 100%; padding: 10px; margin-bottom: 10px; border: 1px solid #ddd; border-radius: 5px;">
        <input id="registerConfirmPasswordInput" type="password" placeholder="Confirm Password" style="width: 100%; padding: 10px; margin-bottom: 10px; border: 1px solid #ddd; border-radius: 5px;">
        <button id="registerBtn" style="width: 100%; background: #6a0dad; color: white; padding: 12px; border: none; border-radius: 5px; cursor: pointer; font-weight: bold;">Register</button>
        <p style="margin-top: 20px; text-align: center;">Already have an account? <a href="#" id="showLoginBtn" style="color: #6a0dad; text-decoration: none;">Login</a></p>
      </div>
    </section>
  
    <!-- Main content section -->
    <section id="mainSectionCtn" hidden style="max-width: 600px; margin: 20px auto; padding: 0 10px;">
      <!-- Vibbles list (threads) -->
      <div id="vibblesCtn" style="background: white; padding: 20px; margin-bottom: 20px; border-radius: 10px; box-shadow: 0 2px 10px rgba(0,0,0,0.1);">
        <h3 style="margin-top: 0; color: #6a0dad;">Vibbles</h3>
        <div id="vibblesList">
          <div class="vibble-item" style="padding: 10px; margin-bottom: 10px; border: 1px solid #eee; border-radius: 5px; cursor: pointer;" onclick="openVibble('kirkkonummi')">
            <h4 style="margin: 0; color: #6a0dad;">Vible-Kirkkonummi</h4>
            <p style="margin: 5px 0 0; font-size: 0.9em; color: #666;">Local community vibble</p>
          </div>
        </div>
      </div>
      
      <!-- Create post form -->
      <div id="createPostCtn" style="background: white; padding: 20px; margin-bottom: 20px; border-radius: 10px; box-shadow: 0 2px 10px rgba(0,0,0,0.1);">
        <h3 style="margin-top: 0; color: #6a0dad;">Share your vibe</h3>
        <textarea id="postContentInput" placeholder="What's on your mind?" style="width: 100%; height: 100px; padding: 10px; margin-bottom: 10px; border: 1px solid #ddd; border-radius: 5px; resize: none;"></textarea>
        <button id="createPostBtn" style="background: #6a0dad; color: white; padding: 10px 20px; border: none; border-radius: 20px; cursor: pointer; float: right;">Post</button>
        <div style="clear: both;"></div>
      </div>
      
      <!-- Posts feed -->
      <div id="postsFeedCtn"></div>
    </section>
  
    <!-- Vibble section (thread view) -->
    <section id="vibbleSectionCtn" hidden style="max-width: 600px; margin: 20px auto; padding: 0 10px;">
      <div style="background: white; padding: 20px; margin-bottom: 20px; border-radius: 10px; box-shadow: 0 2px 10px rgba(0,0,0,0.1);">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
          <button id="backToHomeBtn" style="background: none; border: none; color: #6a0dad; font-size: 0.9em; display: flex; align-items: center; cursor: pointer;">
            <span style="margin-right: 5px;">←</span> Back to Home
          </button>
        </div>
        <h2 id="vibbleTitle" style="margin: 0; color: #6a0dad;">Vible-Kirkkonummi</h2>
        <p id="vibbleDescription" style="margin: 10px 0; color: #666;">Kirkkonummen Puskaradio!</p>
      </div>
      
      <!-- Create post in vibble form -->
      <div id="createVibblePostCtn" style="background: white; padding: 20px; margin-bottom: 20px; border-radius: 10px; box-shadow: 0 2px 10px rgba(0,0,0,0.1);">
        <h3 style="margin-top: 0; color: #6a0dad;">Share with the community</h3>
        <textarea id="vibblePostContentInput" placeholder="What's happening in Kirkkonummi?" style="width: 100%; height: 100px; padding: 10px; margin-bottom: 10px; border: 1px solid #ddd; border-radius: 5px; resize: none;"></textarea>
        <button id="createVibblePostBtn" style="background: #6a0dad; color: white; padding: 10px 20px; border: none; border-radius: 20px; cursor: pointer; float: right;">Post</button>
        <div style="clear: both;"></div>
      </div>
      
      <!-- Vibble posts feed -->
      <div id="vibblePostsFeedCtn"></div>
    </section>
  
    <!-- Profile section -->
    <section id="profileSectionCtn" hidden style="max-width: 600px; margin: 20px auto; padding: 0 10px;">
      <div style="background: white; padding: 20px; margin-bottom: 20px; border-radius: 10px; box-shadow: 0 2px 10px rgba(0,0,0,0.1);">
        <div style="display: flex; align-items: center; margin-bottom: 20px;">
          <div id="profileImageCtn" style="width: 100px; height: 100px; border-radius: 50%; background-color: #ddd; margin-right: 20px; overflow: hidden; position: relative;">
            <img id="currentProfileImg" style="width: 100%; height: 100%; object-fit: cover;">
            <div id="profileUploadOverlay" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); color: white; display: flex; align-items: center; justify-content: center; cursor: pointer; opacity: 0; transition: opacity 0.3s;" onmouseover="this.style.opacity='1'" onmouseout="this.style.opacity='0'">
              Change
            </div>
          </div>
          <div>
            <div id="companyNameDisplay" hidden style="font-size: 1.8em; font-weight: bold; margin-bottom: 5px;"></div>
            <h2 id="profileNameDisplay" style="margin: 0; color: #6a0dad;"></h2>
            <div style="display: flex; align-items: center;">
              <span id="premiumBadge" style="display: none; background: gold; color: #333; font-size: 0.8em; padding: 2px 5px; border-radius: 3px; margin-left: 5px;">✓ Premium</span>
              <span id="companyBadge" style="display: none; margin-left: 5px;" class="golden-checkmark">✓</span>
            </div>
          </div>
        </div>
        
        <h3 style="color: #6a0dad;">Edit Profile</h3>
        <input id="updateUsernameInput" type="text" placeholder="New Username" style="width: 100%; padding: 10px; margin-bottom: 10px; border: 1px solid #ddd; border-radius: 5px;">
        <input id="fileUploadInput" type="file" accept="image/*" hidden>
        <button id="updateProfileBtn" style="background: #6a0dad; color: white; padding: 10px 20px; border: none; border-radius: 20px; cursor: pointer;">Update Profile</button>
      </div>
      
      <!-- Data Management Section -->
      <div style="background: white; padding: 20px; margin-bottom: 20px; border-radius: 10px; box-shadow: 0 2px 10px rgba(0,0,0,0.1);">
        <h3 style="color: #6a0dad;">Data Management</h3>
        <p style="margin-bottom: 15px;">Export your data to transfer posts between devices or to backup your content.</p>
        
        <div style="display: flex; gap: 10px; margin-bottom: 15px;">
          <button id="exportDataBtn" style="flex: 1; background: #6a0dad; color: white; padding: 10px; border: none; border-radius: 5px; cursor: pointer;">Export Data</button>
          <button id="importDataBtn" style="flex: 1; background: white; color: #6a0dad; border: 1px solid #6a0dad; padding: 10px; border-radius: 5px; cursor: pointer;">Import Data</button>
        </div>
        
        <input id="importFileInput" type="file" accept=".json" hidden>
        <div id="saveStatusCtn" style="display: flex; justify-content: center; margin-top: 10px; color: #6a0dad; font-size: 0.9em;"></div>
        <p style="font-size: 0.9em; color: #666; margin-top: 10px;">Note: All posts and comments are saved automatically to the site and will stay forever.</p>
      </div>
      
      <!-- Company Account Application -->
      <div style="background: white; padding: 20px; margin-bottom: 20px; border-radius: 10px; box-shadow: 0 2px 10px rgba(0,0,0,0.1);">
        <h3 style="color: #6a0dad;">Apply for Company Account</h3>
        <div id="companyApplicationFormCtn">
          <input id="companyNameInput" type="text" placeholder="Company Name" style="width: 100%; padding: 10px; margin-bottom: 10px; border: 1px solid #ddd; border-radius: 5px;">
          <textarea id="companyDescriptionInput" placeholder="Company Description" style="width: 100%; height: 80px; padding: 10px; margin-bottom: 10px; border: 1px solid #ddd; border-radius: 5px; resize: none;"></textarea>
          
          <div style="margin-bottom: 15px;">
            <label style="display: block; margin-bottom: 5px; color: #6a0dad;">Choose Username Color:</label>
            <input id="usernameColorInput" type="color" value="#6a0dad" style="width: 100%; height: 40px; cursor: pointer; border: 1px solid #ddd; border-radius: 5px;">
          </div>
          
          <button id="applyForCompanyBtn" style="background: #6a0dad; color: white; padding: 10px 20px; border: none; border-radius: 20px; cursor: pointer;">Apply for Company Account</button>
        </div>
        
        <div id="companyStatusCtn" hidden style="margin-top: 15px; padding: 15px; background: #f8f8f8; border-radius: 5px;">
          <p id="companyStatusText">Your company account application is pending.</p>
          <button id="manageCompanyBtn" style="background: #6a0dad; color: white; padding: 10px 20px; border: none; border-radius: 20px; cursor: pointer;">Manage Company Profile</button>
        </div>
      </div>
      
      <div style="background: white; padding: 20px; border-radius: 10px; box-shadow: 0 2px 10px rgba(0,0,0,0.1);">
        <h3 style="color: #6a0dad;">Your Posts</h3>
        <div id="userPostsCtn"></div>
      </div>
    </section>
  
    <!-- Premium section -->
    <section id="premiumSectionCtn" hidden style="max-width: 600px; margin: 20px auto; padding: 0 10px;">
      <div style="background: white; padding: 20px; border-radius: 10px; box-shadow: 0 2px 10px rgba(0,0,0,0.1);">
        <h2 style="color: #6a0dad;">Vibly Premium</h2>
        <div id="premiumStatusCtn" style="margin-bottom: 20px; padding: 15px; border-radius: 5px; background: #f4f4f4;">
          <p id="premiumStatusText">You are not a Premium member yet.</p>
        </div>
        
        <div id="premiumFeaturesCtn" style="margin-bottom: 20px;">
          <h3 style="color: #6a0dad;">Premium Features:</h3>
          <ul style="padding-left: 20px; line-height: 1.6;">
            <li>Verified checkmark next to your name</li>
            <li>Exclusive purple gradient post backgrounds</li>
            <li>Ability to pin posts to the top of your profile</li>
            <li>Ad-free experience</li>
            <li>Priority in feed algorithm</li>
          </ul>
        </div>
        
        <div id="premiumPricingCtn" style="margin-bottom: 20px; padding: 15px; border-radius: 5px; background: linear-gradient(135deg, #f4f0ff, #e9d5ff);">
          <h3 style="margin-top: 0; color: #6a0dad;">Pricing</h3>
          <p style="font-size: 2em; font-weight: bold; color: #6a0dad; margin: 10px 0;">$4.99 <span style="font-size: 0.5em; font-weight: normal;">/month</span></p>
        </div>
        
        <button id="upgradeToPremiumBtn" style="width: 100%; background: gold; color: #333; padding: 15px; border: none; border-radius: 5px; cursor: pointer; font-weight: bold; font-size: 1.1em;">Upgrade to Premium</button>
        <button id="cancelPremiumBtn" hidden style="width: 100%; background: #f44336; color: white; padding: 15px; border: none; border-radius: 5px; cursor: pointer; font-weight: bold; font-size: 1.1em; margin-top: 10px;">Cancel Premium</button>
      </div>
    </section>
  
    <!-- Post template (hidden, used for cloning) -->
    <div id="postTemplateCtn" hidden style="background: white; padding: 20px; margin-bottom: 20px; border-radius: 10px; box-shadow: 0 2px 10px rgba(0,0,0,0.1);">
      <div class="post-header" style="display: flex; align-items: center; margin-bottom: 10px;">
        <div class="post-avatar" style="width: 40px; height: 40px; border-radius: 50%; background-color: #ddd; margin-right: 10px; overflow: hidden;">
          <img class="post-avatar-img" style="width: 100%; height: 100%; object-fit: cover;">
        </div>
        <div>
          <div class="company-display" style="display: none;">
            <div class="company-name" style="font-weight: bold; font-size: 1.2em;"></div>
          </div>
          <span class="post-username" style="font-weight: bold; color: #6a0dad;"></span>
          <span class="post-premium-badge" style="display: none; background: gold; color: #333; font-size: 0.8em; padding: 1px 4px; border-radius: 3px; margin-left: 5px;">✓</span>
          <span class="post-company-badge" style="display: none; margin-left: 5px;" class="golden-checkmark">✓</span>
          <div class="post-time" style="font-size: 0.8em; color: #888;"></div>
        </div>
      </div>
      <div class="post-content" style="margin-bottom: 15px;"></div>
      <div class="post-actions" style="display: flex; justify-content: space-between; border-top: 1px solid #eee; padding-top: 10px;">
        <button class="like-button" style="background: none; border: none; color: #6a0dad; cursor: pointer; display: flex; align-items: center;">
          <span class="like-icon">♡</span> 
          <span class="like-count" style="margin-left: 5px;">0</span>
        </button>
        <button class="comment-toggle-button" style="background: none; border: none; color: #6a0dad; cursor: pointer;">Show Comments</button>
      </div>
      <div class="comments-section" style="margin-top: 15px; display: none;">
        <div class="comments-container"></div>
      </div>
    </div>
  
    <!-- Comment template (hidden, used for cloning) -->
    <div id="commentTemplateCtn" hidden>
      <div class="comment" style="margin-bottom: 10px; padding: 10px; background: #f9f9f9; border-radius: 5px;">
        <div style="display: flex; align-items: center;">
          <div class="comment-company-display" style="display: none; margin-right: 5px;">
            <span class="comment-company-name" style="font-weight: bold;"></span>
          </div>
          <span class="comment-username" style="font-weight: bold; color: #6a0dad; margin-right: 5px;"></span>
          <span class="comment-premium-badge" style="display: none; background: gold; color: #333; font-size: 0.7em; padding: 1px 3px; border-radius: 3px; margin-right: 5px;">✓</span>
          <span class="comment-company-badge" style="display: none; margin-right: 5px;" class="golden-checkmark">✓</span>
          <span class="comment-time" style="font-size: 0.8em; color: #888;"></span>
        </div>
        <div class="comment-content" style="margin-top: 5px;"></div>
      </div>
    </div>
  </div>
  
  <style>
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: #f5f5f5;
      margin: 0;
      padding: 0;
      color: #333;
      text-align: left;
    }
    
    button:hover {
      opacity: 0.9;
    }
    
    .nav-btn.active {
      background: #6a0dad !important;
      color: white !important;
    }
    
    .premium-post {
      background: linear-gradient(135deg, #fff, #f0e6ff) !important;
      border: 1px solid #e0d0ff;
    }
    
    /* Golden checkmark animation */
    .golden-checkmark {
      color: gold;
      text-shadow: 0 0 5px rgba(255, 215, 0, 0.7);
      font-size: 1.2em;
      font-weight: bold;
      animation: shine 2s infinite;
    }
    
    @keyframes shine {
      0% { text-shadow: 0 0 5px rgba(255, 215, 0, 0.7); }
      50% { text-shadow: 0 0 15px rgba(255, 215, 0, 1); }
      100% { text-shadow: 0 0 5px rgba(255, 215, 0, 0.7); }
    }
    
    .company-post {
      background: linear-gradient(135deg, #fff, #f8f8f8) !important;
      border: 1px solid #e8e8e8;
    }
    
    /* Comments Plugin Custom Styling */
    .vibly-comments-plugin {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      border-radius: 5px;
      background-color: #f9f9f9;
      overflow: hidden;
    }
    
    .vibly-comments-plugin .comments-plugin-thread {
      max-height: 300px;
      overflow-y: auto;
      padding: 10px;
    }
    
    .vibly-comments-plugin .comments-plugin-message {
      background-color: white;
      border-radius: 5px;
      box-shadow: 0 1px 3px rgba(0,0,0,0.1);
      padding: 10px;
      margin-bottom: 10px;
    }
    
    .vibly-comments-plugin .comments-plugin-author {
      font-weight: bold;
      color: #6a0dad;
      margin-right: 5px;
    }
    
    .vibly-comments-plugin .comments-plugin-time {
      font-size: 0.8em;
      color: #888;
    }
    
    .vibly-comments-plugin .comments-plugin-content {
      margin-top: 5px;
    }
    
    .vibly-comments-plugin .comments-plugin-input {
      display: flex;
      padding: 10px;
      background-color: white;
      border-top: 1px solid #eee;
    }
    
    .vibly-comments-plugin .comments-plugin-textarea {
      flex: 1;
      padding: 8px;
      border: 1px solid #ddd;
      border-radius: 20px;
      resize: none;
      margin-right: 10px;
    }
    
    .vibly-comments-plugin .comments-plugin-submit {
      background: #6a0dad;
      color: white;
      border: none;
      padding: 8px 15px;
      border-radius: 20px;
      cursor: pointer;
    }
    
    .vibly-comments-plugin .comments-plugin-submit:hover {
      opacity: 0.9;
    }
    
    /* Avatar styling */
    .vibly-comments-plugin .comments-plugin-avatar {
      width: 32px;
      height: 32px;
      border-radius: 50%;
      margin-right: 10px;
      background-color: #ddd;
    }
    
    .vibly-comments-plugin .comments-plugin-header {
      display: flex;
      align-items: center;
    }
    
    /* Save status animation */
    @keyframes fadeOut {
      0% { opacity: 1; }
      70% { opacity: 1; }
      100% { opacity: 0; }
    }
    
    .save-status {
      animation: fadeOut 3s forwards;
    }
  </style>
  
  <script>
    // Initialize app state
    let currentUser = null;
    let currentVibble = null;
    let autoSaveInterval = null;
  
    // Initialize comments plugin
    let commentsPlugin = function(options) {
      // Default implementation if the global isn't available
      if (window.commentsPlugin) {
        return window.commentsPlugin(options);
      } else {
        return `<div class="comments-plugin-container">
                  <div class="comments-plugin-thread">
                    <div class="comments-plugin-message">
                      <div class="comments-plugin-header">
                        <div class="comments-plugin-avatar"></div>
                        <span class="comments-plugin-author">System</span>
                        <span class="comments-plugin-time">Just now</span>
                      </div>
                      <div class="comments-plugin-content">Comments system is initializing...</div>
                    </div>
                  </div>
                  <div class="comments-plugin-input">
                    <textarea class="comments-plugin-textarea" placeholder="Write a comment..."></textarea>
                    <button class="comments-plugin-submit">Send</button>
                  </div>
                </div>`;
      }
    };
    
    // Enhanced storage system with IndexedDB support for better reliability
    async function createPersistentKV(namespace) {
      // Check for IndexedDB support
      const indexedDBSupported = 'indexedDB' in window;
      
      // Create IndexedDB database if supported
      let db = null;
      if (indexedDBSupported) {
        try {
          db = await new Promise((resolve, reject) => {
            const request = indexedDB.open('viblyDB', 1);
            
            request.onupgradeneeded = function(event) {
              const db = event.target.result;
              // Create object stores for each namespace if they don't exist
              if (!db.objectStoreNames.contains(namespace)) {
                db.createObjectStore(namespace, { keyPath: 'key' });
              }
            };
            
            request.onsuccess = function(event) {
              resolve(event.target.result);
            };
            
            request.onerror = function(event) {
              console.error('IndexedDB error:', event.target.error);
              reject(event.target.error);
            };
          });
        } catch (error) {
          console.error('Error setting up IndexedDB:', error);
        }
      }
      
      // Show save status
      function showSaveStatus(message, isError = false) {
        const saveStatusCtn = document.getElementById('saveStatusCtn');
        if (saveStatusCtn) {
          const statusEl = document.createElement('div');
          statusEl.className = 'save-status';
          statusEl.textContent = message;
          statusEl.style.color = isError ? '#ff4d4d' : '#4CAF50';
          saveStatusCtn.appendChild(statusEl);
          
          // Remove the status message after animation completes
          setTimeout(() => {
            if (statusEl.parentNode === saveStatusCtn) {
              saveStatusCtn.removeChild(statusEl);
            }
          }, 3000);
        }
      }
      
      // Common error handler
      function handleStorageError(error, operation) {
        console.error(`Storage error during ${operation}:`, error);
        showSaveStatus(`Error: ${operation} failed`, true);
      }
      
      // The KV store implementation
      return {
        async get(key) {
          try {
            // Try IndexedDB first
            if (db) {
              try {
                const result = await new Promise((resolve, reject) => {
                  const transaction = db.transaction(namespace, 'readonly');
                  const store = transaction.objectStore(namespace);
                  const request = store.get(key);
                  
                  request.onsuccess = function() {
                    resolve(request.result ? request.result.value : null);
                  };
                  
                  request.onerror = function(event) {
                    reject(event.target.error);
                  };
                });
                
                return result;
              } catch (error) {
                console.warn('IndexedDB get failed, falling back to localStorage:', error);
                // Fall back to localStorage
              }
            }
            
            // Use localStorage as fallback
            const value = localStorage.getItem(`${namespace}_${key}`);
            return value ? JSON.parse(value) : null;
          } catch (error) {
            handleStorageError(error, 'get');
            return null;
          }
        },
        
        async set(key, value) {
          try {
            // Try to save to IndexedDB first
            if (db) {
              try {
                await new Promise((resolve, reject) => {
                  const transaction = db.transaction(namespace, 'readwrite');
                  const store = transaction.objectStore(namespace);
                  const request = store.put({ key, value });
                  
                  request.onsuccess = function() {
                    resolve();
                  };
                  
                  request.onerror = function(event) {
                    reject(event.target.error);
                  };
                });
                
                showSaveStatus('Saved');
                return true;
              } catch (error) {
                console.warn('IndexedDB set failed, falling back to localStorage:', error);
                // Fall back to localStorage
              }
            }
            
            // Use localStorage as fallback
            localStorage.setItem(`${namespace}_${key}`, JSON.stringify(value));
            showSaveStatus('Saved');
            return true;
          } catch (error) {
            handleStorageError(error, 'save');
            return false;
          }
        },
        
        async delete(key) {
          try {
            // Try to delete from IndexedDB first
            if (db) {
              try {
                await new Promise((resolve, reject) => {
                  const transaction = db.transaction(namespace, 'readwrite');
                  const store = transaction.objectStore(namespace);
                  const request = store.delete(key);
                  
                  request.onsuccess = function() {
                    resolve();
                  };
                  
                  request.onerror = function(event) {
                    reject(event.target.error);
                  };
                });
                
                return true;
              } catch (error) {
                console.warn('IndexedDB delete failed, falling back to localStorage:', error);
                // Fall back to localStorage
              }
            }
            
            // Use localStorage as fallback
            localStorage.removeItem(`${namespace}_${key}`);
            return true;
          } catch (error) {
            handleStorageError(error, 'delete');
            return false;
          }
        },
        
        async keys() {
          try {
            // Try to get keys from IndexedDB first
            if (db) {
              try {
                const keys = await new Promise((resolve, reject) => {
                  const transaction = db.transaction(namespace, 'readonly');
                  const store = transaction.objectStore(namespace);
                  const request = store.getAllKeys();
                  
                  request.onsuccess = function() {
                    resolve(request.result.map(key => key));
                  };
                  
                  request.onerror = function(event) {
                    reject(event.target.error);
                  };
                });
                
                return keys;
              } catch (error) {
                console.warn('IndexedDB keys failed, falling back to localStorage:', error);
                // Fall back to localStorage
              }
            }
            
            // Use localStorage as fallback
            const keys = [];
            for (let i = 0; i < localStorage.length; i++) {
              const key = localStorage.key(i);
              if (key.startsWith(`${namespace}_`)) {
                keys.push(key.replace(`${namespace}_`, ''));
              }
            }
            return keys;
          } catch (error) {
            handleStorageError(error, 'get keys');
            return [];
          }
        },
        
        async values() {
          try {
            const values = [];
            const keys = await this.keys();
            for (const key of keys) {
              const value = await this.get(key);
              if (value !== null) {
                values.push(value);
              }
            }
            return values;
          } catch (error) {
            handleStorageError(error, 'get values');
            return [];
          }
        },
        
        async entries() {
          try {
            const entries = [];
            const keys = await this.keys();
            for (const key of keys) {
              const value = await this.get(key);
              if (value !== null) {
                entries.push([key, value]);
              }
            }
            return entries;
          } catch (error) {
            handleStorageError(error, 'get entries');
            return [];
          }
        },
        
        async setMany(entries) {
          try {
            let success = true;
            for (const [key, value] of entries) {
              const result = await this.set(key, value);
              if (!result) success = false;
            }
            return success;
          } catch (error) {
            handleStorageError(error, 'save many');
            return false;
          }
        },
        
        async getMany(keys) {
          try {
            const values = [];
            for (const key of keys) {
              values.push(await this.get(key));
            }
            return values;
          } catch (error) {
            handleStorageError(error, 'get many');
            return [];
          }
        },
        
        async deleteMany(keys) {
          try {
            let success = true;
            for (const key of keys) {
              const result = await this.delete(key);
              if (!result) success = false;
            }
            return success;
          } catch (error) {
            handleStorageError(error, 'delete many');
            return false;
          }
        },
        
        async update(key, updateFn) {
          try {
            const value = await this.get(key);
            const updated = updateFn(value);
            await this.set(key, updated);
            return true;
          } catch (error) {
            handleStorageError(error, 'update');
            return false;
          }
        }
      };
    }
    
    // Legacy localStorage based KV for backward compatibility
    function createLocalStorageKV(namespace) {
      return {
        async get(key) {
          try {
            const value = localStorage.getItem(`${namespace}_${key}`);
            return value ? JSON.parse(value) : null;
          } catch (error) {
            console.error(`Error getting ${key} from ${namespace}:`, error);
            return null;
          }
        },
        async set(key, value) {
          try {
            localStorage.setItem(`${namespace}_${key}`, JSON.stringify(value));
            return true;
          } catch (error) {
            console.error(`Error setting ${key} in ${namespace}:`, error);
            return false;
          }
        },
        async delete(key) {
          try {
            localStorage.removeItem(`${namespace}_${key}`);
            return true;
          } catch (error) {
            console.error(`Error deleting ${key} from ${namespace}:`, error);
            return false;
          }
        },
        async keys() {
          try {
            const keys = [];
            for (let i = 0; i < localStorage.length; i++) {
              const key = localStorage.key(i);
              if (key.startsWith(`${namespace}_`)) {
                keys.push(key.replace(`${namespace}_`, ''));
              }
            }
            return keys;
          } catch (error) {
            console.error(`Error getting keys from ${namespace}:`, error);
            return [];
          }
        },
        async values() {
          try {
            const values = [];
            const keys = await this.keys();
            for (const key of keys) {
              const value = await this.get(key);
              if (value !== null) {
                values.push(value);
              }
            }
            return values;
          } catch (error) {
            console.error(`Error getting values from ${namespace}:`, error);
            return [];
          }
        },
        async entries() {
          try {
            const entries = [];
            const keys = await this.keys();
            for (const key of keys) {
              const value = await this.get(key);
              if (value !== null) {
                entries.push([key, value]);
              }
            }
            return entries;
          } catch (error) {
            console.error(`Error getting entries from ${namespace}:`, error);
            return [];
          }
        },
        async setMany(entries) {
          try {
            for (const [key, value] of entries) {
              await this.set(key, value);
            }
            return true;
          } catch (error) {
            console.error(`Error setting many in ${namespace}:`, error);
            return false;
          }
        },
        async getMany(keys) {
          try {
            const values = [];
            for (const key of keys) {
              values.push(await this.get(key));
            }
            return values;
          } catch (error) {
            console.error(`Error getting many from ${namespace}:`, error);
            return [];
          }
        },
        async deleteMany(keys) {
          try {
            for (const key of keys) {
              await this.delete(key);
            }
            return true;
          } catch (error) {
            console.error(`Error deleting many from ${namespace}:`, error);
            return false;
          }
        },
        async update(key, updateFn) {
          try {
            const value = await this.get(key);
            const updated = updateFn(value);
            await this.set(key, updated);
            return true;
          } catch (error) {
            console.error(`Error updating ${key} in ${namespace}:`, error);
            return false;
          }
        }
      };
    }
    
    // Initialize database
    async function initializeDatabase() {
      try {
        // Try to use IndexedDB with fallback to localStorage
        window.kv = {
          users: await createPersistentKV('users'),
          posts: await createPersistentKV('posts'),
          likes: await createPersistentKV('likes'),
          comments: await createPersistentKV('comments')
        };
        
        console.log('Database initialized with enhanced storage');
      } catch (error) {
        console.error('Error initializing enhanced database, falling back to localStorage:', error);
        
        // Fallback to pure localStorage
        window.kv = {
          users: createLocalStorageKV('users'),
          posts: createLocalStorageKV('posts'),
          likes: createLocalStorageKV('likes'),
          comments: createLocalStorageKV('comments')
        };
      }
    }
    
    // Start auto-save timer
    function setupAutoSave() {
      // Clear previous interval if it exists
      if (autoSaveInterval) {
        clearInterval(autoSaveInterval);
      }
      
      // Auto-save current state every 5 minutes
      autoSaveInterval = setInterval(async () => {
        if (currentUser) {
          try {
            // Create auto-backup
            await createAutoBackup();
          } catch (error) {
            console.error('Auto-backup failed:', error);
          }
        }
      }, 5 * 60 * 1000); // 5 minutes
    }
    
    // Create automatic backup
    async function createAutoBackup() {
      try {
        // Get all data
        const users = await kv.users.values();
        const posts = await kv.posts.values();
        
        // Get all post IDs to fetch comments and likes
        const postIds = await kv.posts.keys();
        
        // Create an object to store comments and likes
        const commentsMap = {};
        const likesMap = {};
        
        for (const postId of postIds) {
          const comments = await kv.comments.get(postId) || [];
          const likes = await kv.likes.get(postId) || [];
          
          commentsMap[postId] = comments;
          likesMap[postId] = likes;
        }
        
        // Create export data object
        const exportData = {
          users,
          posts,
          comments: commentsMap,
          likes: likesMap,
          exportDate: new Date().toISOString(),
          version: "1.0"
        };
        
        // Convert to JSON string
        const jsonData = JSON.stringify(exportData);
        
        // Save to localStorage as backup
        try {
          localStorage.setItem('vibly_auto_backup', jsonData);
          console.log('Auto backup created at', new Date().toLocaleTimeString());
        } catch (e) {
          // If localStorage is full, try to save a smaller backup with just user data
          console.warn('Full backup failed, creating minimal backup');
          const minimalBackup = {
            users,
            exportDate: new Date().toISOString(),
            version: "1.0.minimal"
          };
          localStorage.setItem('vibly_auto_backup_minimal', JSON.stringify(minimalBackup));
        }
      } catch (error) {
        console.error('Auto backup creation failed:', error);
      }
    }
    
    // Check if user is logged in
    async function checkLoginStatus() {
      await initializeDatabase();
      
      const savedUser = localStorage.currentUser;
      if (savedUser) {
        try {
          currentUser = JSON.parse(savedUser);
          await showMainInterface();
          setupAutoSave();
        } catch (e) {
          console.error("Error loading user", e);
          showAuthInterface();
        }
      } else {
        showAuthInterface();
      }
      
      // Check for auto-restore if needed
      const hasAutoBackup = localStorage.getItem('vibly_auto_backup');
      if (hasAutoBackup && !localStorage.getItem('auto_backup_checked')) {
        localStorage.setItem('auto_backup_checked', 'true');
        
        if (confirm('We found a previous backup of your data. Would you like to restore it?')) {
          await restoreFromAutoBackup();
        }
      }
    }
    
    // Restore from auto-backup
    async function restoreFromAutoBackup() {
      try {
        const backupData = localStorage.getItem('vibly_auto_backup');
        if (!backupData) return;
        
        const importData = JSON.parse(backupData);
        
        // Validate import data
        if (!importData.posts || !importData.comments || !importData.likes) {
          throw new Error("Invalid backup data");
        }
        
        // Import users but don't overwrite current user
        for (const user of importData.users) {
          if (currentUser && user.username !== currentUser.username) {
            const existingUser = await kv.users.get(user.username);
            if (!existingUser) {
              await kv.users.set(user.username, user);
            }
          }
        }
        
        // Import posts
        for (const post of importData.posts) {
          await kv.posts.set(post.id, post);
        }
        
        // Import comments
        for (const [postId, comments] of Object.entries(importData.comments)) {
          await kv.comments.set(postId, comments);
        }
        
        // Import likes
        for (const [postId, likes] of Object.entries(importData.likes)) {
          await kv.likes.set(postId, likes);
        }
        
        // Reload content
        if (mainSectionCtn.hidden === false) {
          await loadPosts();
        } else if (vibbleSectionCtn.hidden === false && currentVibble) {
          await loadVibblePosts(currentVibble);
        } else if (profileSectionCtn.hidden === false) {
          await loadUserPosts();
        }
        
        alert("Backup data restored successfully!");
        
      } catch (error) {
        console.error("Error restoring from backup:", error);
        alert("Error restoring from backup: " + error.message);
      }
    }
    
    // Show login/register interface
    function showAuthInterface() {
      authSectionCtn.hidden = false;
      mainSectionCtn.hidden = true;
      profileSectionCtn.hidden = true;
      premiumSectionCtn.hidden = true;
      vibbleSectionCtn.hidden = true;
      headerEl.hidden = true;
    }
    
    // Show main app interface
    async function showMainInterface() {
      authSectionCtn.hidden = true;
      mainSectionCtn.hidden = false;
      profileSectionCtn.hidden = true;
      premiumSectionCtn.hidden = true;
      vibbleSectionCtn.hidden = true;
      headerEl.hidden = false;
      
      // Update UI based on current user
      updateUIForUser();
      
      // Load posts
      await loadPosts();
    }
    
    // Open a specific vibble
    async function openVibble(vibbleId) {
      currentVibble = vibbleId;
      
      mainSectionCtn.hidden = true;
      profileSectionCtn.hidden = true;
      premiumSectionCtn.hidden = true;
      vibbleSectionCtn.hidden = false;
      
      // Load vibble-specific posts
      await loadVibblePosts(vibbleId);
    }
    
    // Update UI elements based on current user
    function updateUIForUser() {
      if (!currentUser) return;
      
      // Update premium badge visibility
      premiumBadge.style.display = currentUser.isPremium ? 'inline' : 'none';
      
      // Update company badge and info if applicable
      if (currentUser.isCompany) {
        companyBadge.style.display = 'inline';
        companyNameDisplay.hidden = false;
        companyNameDisplay.textContent = currentUser.companyName;
        companyNameDisplay.style.color = currentUser.usernameColor || '#6a0dad';
        profileNameDisplay.style.color = currentUser.usernameColor || '#6a0dad';
        
        // Update company application status
        companyApplicationFormCtn.hidden = true;
        companyStatusCtn.hidden = false;
        companyStatusText.innerHTML = `Your company account <strong>${currentUser.companyName}</strong> is active.`;
      } else {
        companyBadge.style.display = 'none';
        companyNameDisplay.hidden = true;
        companyApplicationFormCtn.hidden = false;
        companyStatusCtn.hidden = true;
      }
      
      // Update profile section
      profileNameDisplay.textContent = currentUser.username;
      updateUsernameInput.value = currentUser.username;
      
      if (currentUser.profilePic) {
        currentProfileImg.src = currentUser.profilePic;
      }
      
      // Update premium section
      if (currentUser.isPremium) {
        premiumStatusText.innerHTML = '<span style="color: #6a0dad; font-weight: bold;">You are a Premium member!</span> Enjoy all the exclusive features.';
        upgradeToPremiumBtn.hidden = true;
        cancelPremiumBtn.hidden = false;
      } else {
        premiumStatusText.textContent = 'You are not a Premium member yet.';
        upgradeToPremiumBtn.hidden = false;
        cancelPremiumBtn.hidden = true;
      }
    }
    
    // Navigation functions
    function showHome() {
      mainSectionCtn.hidden = false;
      profileSectionCtn.hidden = true;
      premiumSectionCtn.hidden = true;
      vibbleSectionCtn.hidden = true;
      setActiveNavButton(homeBtn);
    }
    
    function showProfile() {
      mainSectionCtn.hidden = true;
      profileSectionCtn.hidden = false;
      premiumSectionCtn.hidden = true;
      vibbleSectionCtn.hidden = true;
      setActiveNavButton(profileBtn);
      loadUserPosts();
    }
    
    function showPremium() {
      mainSectionCtn.hidden = true;
      profileSectionCtn.hidden = true;
      premiumSectionCtn.hidden = false;
      vibbleSectionCtn.hidden = true;
      setActiveNavButton(premiumBtn);
    }
    
    function setActiveNavButton(activeBtn) {
      // Remove active class from all nav buttons
      document.querySelectorAll('.nav-btn').forEach(btn => {
        btn.classList.remove('active');
        btn.style.background = 'white';
        btn.style.color = '#6a0dad';
      });
      
      // Add active class to the clicked button
      activeBtn.classList.add('active');
      activeBtn.style.background = '#6a0dad';
      activeBtn.style.color = 'white';
    }
    
    // User authentication
    async function login() {
      const username = loginUsernameInput.value.trim();
      const password = loginPasswordInput.value;
      
      if (!username || !password) {
        alert("Please enter both username and password");
        return;
      }
      
      try {
        const user = await kv.users.get(username);
        
        if (!user) {
          alert("User not found. Please register.");
          return;
        }
        
        if (user.password !== password) {
          alert("Incorrect password");
          return;
        }
        
        // Login successful
        currentUser = user;
        localStorage.currentUser = JSON.stringify(user);
        showMainInterface();
        setupAutoSave();
        
      } catch (error) {
        console.error("Login error:", error);
        alert("Error during login. Please try again.");
      }
    }
    
    async function register() {
      const username = registerUsernameInput.value.trim();
      const password = registerPasswordInput.value;
      const confirmPassword = registerConfirmPasswordInput.value;
      
      if (!username || !password) {
        alert("Please enter both username and password");
        return;
      }
      
      if (password !== confirmPassword) {
        alert("Passwords don't match");
        return;
      }
      
      try {
        // Check if user already exists
        const existingUser = await kv.users.get(username);
        
        if (existingUser) {
          alert("Username already taken");
          return;
        }
        
        // Create new user
        const newUser = {
          username,
          password,
          profilePic: null,
          isPremium: false,
          isCompany: false,
          joinDate: new Date().toISOString()
        };
        
        await kv.users.set(username, newUser);
        
        // Login the new user
        currentUser = newUser;
        localStorage.currentUser = JSON.stringify(newUser);
        alert("Registration successful!");
        showMainInterface();
        setupAutoSave();
        
      } catch (error) {
        console.error("Registration error:", error);
        alert("Error during registration. Please try again.");
      }
    }
    
    function logout() {
      localStorage.removeItem('currentUser');
      currentUser = null;
      
      // Clear auto-save interval
      if (autoSaveInterval) {
        clearInterval(autoSaveInterval);
        autoSaveInterval = null;
      }
      
      showAuthInterface();
    }
    
    // Company account application
    async function applyForCompanyAccount() {
      const companyName = companyNameInput.value.trim();
      const companyDescription = companyDescriptionInput.value.trim();
      const usernameColor = usernameColorInput.value;
      
      if (!companyName) {
        alert("Please enter a company name");
        return;
      }
      
      try {
        // Update user with company information
        currentUser.isCompany = true;
        currentUser.companyName = companyName;
        currentUser.companyDescription = companyDescription;
        currentUser.usernameColor = usernameColor;
        
        // Save updated user
        await kv.users.set(currentUser.username, currentUser);
        
        // Update posts to show company status
        const allPosts = await kv.posts.values();
        const userPosts = allPosts.filter(post => post.userId === currentUser.username);
        
        for (const post of userPosts) {
          post.isCompanyPost = true;
          post.companyName = companyName;
          post.usernameColor = usernameColor;
          await kv.posts.set(post.id, post);
        }
        
        // Update comments to show company status
        const allPostIds = await kv.posts.keys();
        
        for (const postId of allPostIds) {
          const comments = await kv.comments.get(postId) || [];
          let updated = false;
          
          for (const comment of comments) {
            if (comment.userId === currentUser.username) {
              comment.isCompanyComment = true;
              comment.companyName = companyName;
              comment.usernameColor = usernameColor;
              updated = true;
            }
          }
          
          if (updated) {
            await kv.comments.set(postId, comments);
          }
        }
        
        // Save to localStorage
        localStorage.currentUser = JSON.stringify(currentUser);
        
        // Update UI
        updateUIForUser();
        
        alert("Your company account has been created!");
        
        // Create a backup after important changes
        await createAutoBackup();
        
      } catch (error) {
        console.error("Error creating company account:", error);
        alert("Error creating company account. Please try again.");
      }
    }
    
    // Post functionality
    async function createPost() {
      const content = postContentInput.value.trim();
      
      if (!content) {
        alert("Please enter some content for your post");
        return;
      }
      
      try {
        const postId = `post_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
        const newPost = {
          id: postId,
          userId: currentUser.username,
          username: currentUser.username,
          content,
          timestamp: new Date().toISOString(),
          isPremiumUser: currentUser.isPremium,
          threadId: null, // null indicates it's on the main feed
          isCompanyPost: currentUser.isCompany,
          companyName: currentUser.companyName,
          usernameColor: currentUser.usernameColor
        };
        
        await kv.posts.set(postId, newPost);
        
        // Clear input
        postContentInput.value = '';
        
        // Reload posts
        await loadPosts();
        
        // Scroll to top
        window.scrollTo(0, 0);
        
      } catch (error) {
        console.error("Error creating post:", error);
        alert("Error creating post. Please try again.");
      }
    }
    
    // Create post in a vibble/thread
    async function createVibblePost() {
      const content = vibblePostContentInput.value.trim();
      
      if (!content) {
        alert("Please enter some content for your post");
        return;
      }
      
      if (!currentVibble) {
        alert("Error: No vibble selected");
        return;
      }
      
      try {
        const postId = `post_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
        const newPost = {
          id: postId,
          userId: currentUser.username,
          username: currentUser.username,
          content,
          timestamp: new Date().toISOString(),
          isPremiumUser: currentUser.isPremium,
          threadId: currentVibble, // Set the threadId to the current vibble
          isCompanyPost: currentUser.isCompany,
          companyName: currentUser.companyName,
          usernameColor: currentUser.usernameColor
        };
        
        await kv.posts.set(postId, newPost);
        
        // Clear input
        vibblePostContentInput.value = '';
        
        // Reload vibble posts
        await loadVibblePosts(currentVibble);
        
        // Scroll to top
        window.scrollTo(0, 0);
        
      } catch (error) {
        console.error("Error creating vibble post:", error);
        alert("Error creating post. Please try again.");
      }
    }
    
    async function loadPosts() {
      try {
        // Clear existing posts
        postsFeedCtn.innerHTML = '<div style="text-align:center; padding:20px;">Loading posts...</div>';
        
        // Get all posts
        const allPosts = await kv.posts.values();
        
        // Clear the loading message
        postsFeedCtn.innerHTML = '';
        
        // Check if we got posts
        if (!allPosts || allPosts.length === 0) {
          postsFeedCtn.innerHTML = '<p style="text-align:center; padding:20px; background:white; border-radius:10px;">No posts yet. Be the first to post!</p>';
          return;
        }
        
        // Filter to show only main feed posts (no threadId)
        const mainFeedPosts = allPosts.filter(post => !post.threadId);
        
        if (mainFeedPosts.length === 0) {
          postsFeedCtn.innerHTML = '<p style="text-align:center; padding:20px; background:white; border-radius:10px;">No posts in the main feed yet. Be the first to post!</p>';
          return;
        }
        
        // Sort posts by timestamp (newest first)
        mainFeedPosts.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
        
        // Display posts
        for (const post of mainFeedPosts) {
          await displayPost(post, postsFeedCtn);
        }
        
      } catch (error) {
        console.error("Error loading posts:", error);
        postsFeedCtn.innerHTML = '<p style="text-align:center; padding:20px; background:white; border-radius:10px; color:#ff4d4d;">Error loading posts. Please refresh the page or try again later.</p>';
      }
    }
    
    async function loadVibblePosts(vibbleId) {
      try {
        // Clear existing posts
        vibblePostsFeedCtn.innerHTML = '<div style="text-align:center; padding:20px;">Loading posts...</div>';
        
        // Get all posts
        const allPosts = await kv.posts.values();
        
        // Clear the loading message
        vibblePostsFeedCtn.innerHTML = '';
        
        // Check if we got posts
        if (!allPosts || allPosts.length === 0) {
          vibblePostsFeedCtn.innerHTML = '<p style="text-align:center; padding:20px; background:white; border-radius:10px;">No posts in this vibble yet. Be the first to post!</p>';
          return;
        }
        
        // Filter to show only posts from the specified vibble
        const vibblePosts = allPosts.filter(post => post.threadId === vibbleId);
        
        if (vibblePosts.length === 0) {
          vibblePostsFeedCtn.innerHTML = '<p style="text-align:center; padding:20px; background:white; border-radius:10px;">No posts in this vibble yet. Be the first to post!</p>';
          return;
        }
        
        // Sort posts by timestamp (newest first)
        vibblePosts.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
        
        // Display posts
        for (const post of vibblePosts) {
          await displayPost(post, vibblePostsFeedCtn);
        }
        
      } catch (error) {
        console.error("Error loading vibble posts:", error);
        vibblePostsFeedCtn.innerHTML = '<p style="text-align:center; padding:20px; background:white; border-radius:10px; color:#ff4d4d;">Error loading posts. Please refresh the page or try again later.</p>';
      }
    }
    
    async function loadUserPosts() {
      try {
        // Clear existing posts
        userPostsCtn.innerHTML = '<div style="text-align:center; padding:20px;">Loading your posts...</div>';
        
        // Get all posts
        const allPosts = await kv.posts.values();
        
        // Clear the loading message
        userPostsCtn.innerHTML = '';
        
        // Check if we got posts
        if (!allPosts || allPosts.length === 0) {
          userPostsCtn.innerHTML = '<p>You haven\'t created any posts yet.</p>';
          return;
        }
        
        // Filter posts by current user
        const userPosts = allPosts.filter(post => post.userId === currentUser.username);
        
        if (userPosts.length === 0) {
          userPostsCtn.innerHTML = '<p>You haven\'t created any posts yet.</p>';
          return;
        }
        
        // Sort posts by timestamp (newest first)
        userPosts.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
        
        // Display posts
        for (const post of userPosts) {
          await displayPost(post, userPostsCtn);
        }
        
      } catch (error) {
        console.error("Error loading user posts:", error);
        userPostsCtn.innerHTML = '<p style="color:#ff4d4d;">Error loading your posts. Please refresh the page or try again later.</p>';
      }
    }
    
    async function displayPost(post, container) {
      try {
        // Clone the post template
        const postEl = postTemplateCtn.cloneNode(true);
        postEl.id = `post_${post.id}`;
        postEl.hidden = false;
        
        // Set post data
        const usernameEl = postEl.querySelector('.post-username');
        const avatarImgEl = postEl.querySelector('.post-avatar-img');
        const timeEl = postEl.querySelector('.post-time');
        const contentEl = postEl.querySelector('.post-content');
        const premiumBadge = postEl.querySelector('.post-premium-badge');
        const likeBtn = postEl.querySelector('.like-button');
        const likeIcon = postEl.querySelector('.like-icon');
        const likeCount = postEl.querySelector('.like-count');
        const commentToggleBtn = postEl.querySelector('.comment-toggle-button');
        const commentsSection = postEl.querySelector('.comments-section');
        const commentsContainer = postEl.querySelector('.comments-container');
        const companyBadge = postEl.querySelector('.post-company-badge');
        const companyDisplay = postEl.querySelector('.company-display');
        const companyName = postEl.querySelector('.company-name');
        
        usernameEl.textContent = post.username;
        
        // Set username color if it's a company post
        if (post.usernameColor) {
          usernameEl.style.color = post.usernameColor;
        }
        
        // Show company name and badge if it's a company post
        if (post.isCompanyPost && post.companyName) {
          companyDisplay.style.display = 'block';
          companyName.textContent = post.companyName;
          companyBadge.style.display = 'inline';
          postEl.classList.add('company-post');
        }
        
        // Get user info to show profile pic and premium status
        const postUser = await kv.users.get(post.userId);
        if (postUser && postUser.profilePic) {
          avatarImgEl.src = postUser.profilePic;
        }
        
        // Show premium badge if user is premium
        if (post.isPremiumUser) {
          premiumBadge.style.display = 'inline';
          postEl.classList.add('premium-post');
        }
        
        // Format and display timestamp
        const postDate = new Date(post.timestamp);
        timeEl.textContent = formatDate(postDate);
        
        // Set post content
        contentEl.textContent = post.content;
        
        // Set up likes
        let likes = await kv.likes.get(post.id) || [];
        likeCount.textContent = likes.length;
        
        // Check if current user liked this post
        if (likes.includes(currentUser.username)) {
          likeIcon.textContent = '♥';
          likeIcon.style.color = '#ff4d4d';
        }
        
        // Like button event
        likeBtn.onclick = async () => {
          try {
            // Get current likes
            let currentLikes = await kv.likes.get(post.id) || [];
            
            // Check if user already liked
            const userLikedIndex = currentLikes.indexOf(currentUser.username);
            
            if (userLikedIndex === -1) {
              // Add like
              currentLikes.push(currentUser.username);
              likeIcon.textContent = '♥';
              likeIcon.style.color = '#ff4d4d';
            } else {
              // Remove like
              currentLikes.splice(userLikedIndex, 1);
              likeIcon.textContent = '♡';
              likeIcon.style.color = '#6a0dad';
            }
            
            // Update likes in storage
            await kv.likes.set(post.id, currentLikes);
            
            // Update UI
            likeCount.textContent = currentLikes.length;
            
          } catch (error) {
            console.error("Error updating like:", error);
            alert("Error updating like. Please try again.");
          }
        };
        
        // Initialize comments plugin for this post
        commentsContainer.innerHTML = commentsPlugin({
          channel: `post_comments_${post.id}`,
          width: "100%",
          height: "auto"
        });
        
        // Add Vibly styling to comments plugin
        const pluginContainer = commentsContainer.querySelector('.comments-plugin-container');
        if (pluginContainer) {
          pluginContainer.classList.add('vibly-comments-plugin');
        }
        
        // Comment toggle button
        commentToggleBtn.onclick = () => {
          if (commentsSection.style.display === 'none') {
            commentsSection.style.display = 'block';
            commentToggleBtn.textContent = 'Hide Comments';
          } else {
            commentsSection.style.display = 'none';
            commentToggleBtn.textContent = 'Show Comments';
          }
        };
        
        // Add post to container
        container.appendChild(postEl);
      } catch (error) {
        console.error("Error displaying post:", error);
        // Handle error gracefully without breaking the UI
      }
    }
    
    // Profile functionality
    async function updateProfile() {
      const newUsername = updateUsernameInput.value.trim();
      
      if (!newUsername) {
        alert("Please enter a username");
        return;
      }
      
      try {
        // Check if new username is different and not taken
        if (newUsername !== currentUser.username) {
          const existingUser = await kv.users.get(newUsername);
          
          if (existingUser) {
            alert("Username already taken");
            return;
          }
          
          // Copy user data to new username
          const updatedUser = { ...currentUser, username: newUsername };
          
          // Save user with new username
          await kv.users.set(newUsername, updatedUser);
          
          // Delete old username entry
          await kv.users.delete(currentUser.username);
          
          // Update posts and comments with new username
          await updateUserContent(currentUser.username, newUsername);
          
          // Update current user
          currentUser = updatedUser;
        } else {
          // Just update the existing user
          await kv.users.set(currentUser.username, currentUser);
        }
        
        // Save to localStorage
        localStorage.currentUser = JSON.stringify(currentUser);
        
        // Update UI
        updateUIForUser();
        
        // Create backup after profile update
        await createAutoBackup();
        
        alert("Profile updated successfully!");
        
      } catch (error) {
        console.error("Error updating profile:", error);
        alert("Error updating profile. Please try again.");
      }
    }
    
    async function updateUserContent(oldUsername, newUsername) {
      try {
        // Update posts
        const allPosts = await kv.posts.values();
        const userPosts = allPosts.filter(post => post.userId === oldUsername);
        
        for (const post of userPosts) {
          post.userId = newUsername;
          post.username = newUsername;
          await kv.posts.set(post.id, post);
        }
        
        // Update comments
        const allPostIds = await kv.posts.keys();
        
        for (const postId of allPostIds) {
          const comments = await kv.comments.get(postId) || [];
          let updated = false;
          
          for (const comment of comments) {
            if (comment.userId === oldUsername) {
              comment.userId = newUsername;
              comment.username = newUsername;
              updated = true;
            }
          }
          
          if (updated) {
            await kv.comments.set(postId, comments);
          }
        }
        
        // Update likes
        const allLikePostIds = await kv.likes.keys();
        
        for (const postId of allLikePostIds) {
          const likes = await kv.likes.get(postId) || [];
          const userLikeIndex = likes.indexOf(oldUsername);
          
          if (userLikeIndex !== -1) {
            likes[userLikeIndex] = newUsername;
            await kv.likes.set(postId, likes);
          }
        }
        
      } catch (error) {
        console.error("Error updating user content:", error);
      }
    }
    
    // Premium functionality
    async function upgradeToPremium() {
      try {
        // Simulate payment
        const confirmed = confirm("Upgrade to Vibly Premium for $4.99/month?");
        
        if (!confirmed) return;
        
        // Update user data
        currentUser.isPremium = true;
        
        // Save updated user
        await kv.users.set(currentUser.username, currentUser);
        
        // Update posts to show premium status
        const allPosts = await kv.posts.values();
        const userPosts = allPosts.filter(post => post.userId === currentUser.username);
        
        for (const post of userPosts) {
          post.isPremiumUser = true;
          await kv.posts.set(post.id, post);
        }
        
        // Update comments to show premium status
        const allPostIds = await kv.posts.keys();
        
        for (const postId of allPostIds) {
          const comments = await kv.comments.get(postId) || [];
          let updated = false;
          
          for (const comment of comments) {
            if (comment.userId === currentUser.username) {
              comment.isPremiumUser = true;
              updated = true;
            }
          }
          
          if (updated) {
            await kv.comments.set(postId, comments);
          }
        }
        
        // Save to localStorage
        localStorage.currentUser = JSON.stringify(currentUser);
        
        // Update UI
        updateUIForUser();
        
        // Backup data after premium upgrade
        await createAutoBackup();
        
        alert("You are now a Vibly Premium member! Enjoy your exclusive features.");
        
      } catch (error) {
        console.error("Error upgrading to premium:", error);
        alert("Error upgrading to premium. Please try again.");
      }
    }
    
    async function cancelPremium() {
      try {
        const confirmed = confirm("Are you sure you want to cancel your Premium membership?");
        
        if (!confirmed) return;
        
        // Update user data
        currentUser.isPremium = false;
        
        // Save updated user
        await kv.users.set(currentUser.username, currentUser);
        
        // Update posts to show non-premium status
        const allPosts = await kv.posts.values();
        const userPosts = allPosts.filter(post => post.userId === currentUser.username);
        
        for (const post of userPosts) {
          post.isPremiumUser = false;
          await kv.posts.set(post.id, post);
        }
        
        // Update comments to show non-premium status
        const allPostIds = await kv.posts.keys();
        
        for (const postId of allPostIds) {
          const comments = await kv.comments.get(postId) || [];
          let updated = false;
          
          for (const comment of comments) {
            if (comment.userId === currentUser.username) {
              comment.isPremiumUser = false;
              updated = true;
            }
          }
          
          if (updated) {
            await kv.comments.set(postId, comments);
          }
        }
        
        // Save to localStorage
        localStorage.currentUser = JSON.stringify(currentUser);
        
        // Update UI
        updateUIForUser();
        
        alert("Your Premium membership has been canceled.");
        
      } catch (error) {
        console.error("Error canceling premium:", error);
        alert("Error canceling premium. Please try again.");
      }
    }
    
    // Data Export/Import Functionality
    async function exportData() {
      try {
        // Show loading state
        exportDataBtn.textContent = "Exporting...";
        exportDataBtn.disabled = true;
        
        // Get all data
        const users = await kv.users.values();
        const posts = await kv.posts.values();
        
        // Get all post IDs to fetch comments and likes
        const postIds = await kv.posts.keys();
        
        // Create an object to store comments and likes
        const commentsMap = {};
        const likesMap = {};
        
        for (const postId of postIds) {
          const comments = await kv.comments.get(postId) || [];
          const likes = await kv.likes.get(postId) || [];
          
          commentsMap[postId] = comments;
          likesMap[postId] = likes;
        }
        
        // Create export data object
        const exportData = {
          users,
          posts,
          comments: commentsMap,
          likes: likesMap,
          exportDate: new Date().toISOString(),
          version: "1.0"
        };
        
        // Convert to JSON string
        const jsonData = JSON.stringify(exportData);
        
        // Create download link
        const blob = new Blob([jsonData], { type: "application/json" });
        const url = URL.createObjectURL(blob);
        const link = document.createElement("a");
        link.href = url;
        link.download = "vibly_data_backup.json";
        link.click();
        
        // Clean up
        URL.revokeObjectURL(url);
        
        // Reset button
        exportDataBtn.textContent = "Export Data";
        exportDataBtn.disabled = false;
        
        alert("Data exported successfully!");
      } catch (error) {
        console.error("Error exporting data:", error);
        alert("Error exporting data. Please try again.");
        
        // Reset button
        exportDataBtn.textContent = "Export Data";
        exportDataBtn.disabled = false;
      }
    }
    
    async function importData() {
      // Trigger file input
      importFileInput.click();
    }
    
    async function processImportFile() {
      if (!importFileInput.files || !importFileInput.files[0]) return;
      
      try {
        // Show loading state
        importDataBtn.textContent = "Importing...";
        importDataBtn.disabled = true;
        
        // Read the file
        const file = importFileInput.files[0];
        const reader = new FileReader();
        
        reader.onload = async (e) => {
          try {
            // Parse JSON data
            const importData = JSON.parse(e.target.result);
            
            // Validate import data
            if (!importData.posts || !importData.comments || !importData.likes) {
              throw new Error("Invalid import file format");
            }
            
            // Warning if site already has data
            const existingPosts = await kv.posts.values();
            if (existingPosts.length > 0) {
              const proceed = confirm("This will merge imported data with existing data. Some content may be overwritten. Continue?");
              if (!proceed) {
                importDataBtn.textContent = "Import Data";
                importDataBtn.disabled = false;
                return;
              }
            }
            
            // Import users (but don't overwrite current user)
            for (const user of importData.users) {
              if (user.username !== currentUser.username) {
                const existingUser = await kv.users.get(user.username);
                if (!existingUser) {
                  await kv.users.set(user.username, user);
                }
              }
            }
            
            // Import posts
            for (const post of importData.posts) {
              await kv.posts.set(post.id, post);
            }
            
            // Import comments
            for (const [postId, comments] of Object.entries(importData.comments)) {
              await kv.comments.set(postId, comments);
            }
            
            // Import likes
            for (const [postId, likes] of Object.entries(importData.likes)) {
              await kv.likes.set(postId, likes);
            }
            
            // Reset button
            importDataBtn.textContent = "Import Data";
            importDataBtn.disabled = false;
            
            // Clear file input
            importFileInput.value = "";
            
            // Reload posts
            if (mainSectionCtn.hidden === false) {
              await loadPosts();
            } else if (vibbleSectionCtn.hidden === false && currentVibble) {
              await loadVibblePosts(currentVibble);
            } else if (profileSectionCtn.hidden === false) {
              await loadUserPosts();
            }
            
            alert("Data imported successfully!");
            
          } catch (error) {
            console.error("Error processing import file:", error);
            alert("Error importing data: " + error.message);
            
            // Reset button
            importDataBtn.textContent = "Import Data";
            importDataBtn.disabled = false;
          }
        };
        
        reader.onerror = () => {
          console.error("Error reading file");
          alert("Error reading file. Please try again.");
          
          // Reset button
          importDataBtn.textContent = "Import Data";
          importDataBtn.disabled = false;
        };
        
        reader.readAsText(file);
        
      } catch (error) {
        console.error("Error importing data:", error);
        alert("Error importing data. Please try again.");
        
        // Reset button
        importDataBtn.textContent = "Import Data";
        importDataBtn.disabled = false;
      }
    }
    
    // Utility functions
    function formatDate(date) {
      const now = new Date();
      const diffMs = now - date;
      const diffSecs = Math.floor(diffMs / 1000);
      const diffMins = Math.floor(diffSecs / 60);
      const diffHours = Math.floor(diffMins / 60);
      const diffDays = Math.floor(diffHours / 24);
      
      if (diffSecs < 60) {
        return "Just now";
      } else if (diffMins < 60) {
        return `${diffMins}m ago`;
      } else if (diffHours < 24) {
        return `${diffHours}h ago`;
      } else if (diffDays < 7) {
        return `${diffDays}d ago`;
      } else {
        return date.toLocaleDateString();
      }
    }
    
    // Event listeners
    
    // Auth form toggling
    showRegisterBtn.addEventListener('click', function(e) {
      e.preventDefault();
      loginFormCtn.hidden = true;
      registerFormCtn.hidden = false;
    });
    
    showLoginBtn.addEventListener('click', function(e) {
      e.preventDefault();
      loginFormCtn.hidden = false;
      registerFormCtn.hidden = true;
    });
    
    // Login/Register form submission
    loginBtn.addEventListener('click', login);
    registerBtn.addEventListener('click', register);
    
    // Navigation
    homeBtn.addEventListener('click', showHome);
    profileBtn.addEventListener('click', showProfile);
    premiumBtn.addEventListener('click', showPremium);
    logoutBtn.addEventListener('click', logout);
    backToHomeBtn.addEventListener('click', showHome);
    
    // Post creation
    createPostBtn.addEventListener('click', createPost);
    createVibblePostBtn.addEventListener('click', createVibblePost);
    
    // Profile update
    updateProfileBtn.addEventListener('click', updateProfile);
    profileImageCtn.addEventListener('click', function() {
      fileUploadInput.click();
    });
    
    // Company account application
    applyForCompanyBtn.addEventListener('click', applyForCompanyAccount);
    
    // Data import/export
    exportDataBtn.addEventListener('click', exportData);
    importDataBtn.addEventListener('click', importData);
    importFileInput.addEventListener('change', processImportFile);
    
    fileUploadInput.addEventListener('change', async function() {
      if (this.files && this.files[0]) {
        const file = this.files[0];
        
        // Check file size (max 1MB)
        if (file.size > 1024 * 1024) {
          alert("File too large. Please select an image smaller than 1MB.");
          return;
        }
        
        // Read file as data URL
        const reader = new FileReader();
        reader.onload = async function(e) {
          try {
            // Update user profile pic
            currentUser.profilePic = e.target.result;
            currentProfileImg.src = e.target.result;
            
            // Save updated user
            await kv.users.set(currentUser.username, currentUser);
            
            // Save to localStorage
            localStorage.currentUser = JSON.stringify(currentUser);
            
          } catch (error) {
            console.error("Error updating profile picture:", error);
            alert("Error updating profile picture. Please try again.");
          }
        };
        reader.readAsDataURL(file);
      }
    });
    
    // Premium
    upgradeToPremiumBtn.addEventListener('click', upgradeToPremium);
    cancelPremiumBtn.addEventListener('click', cancelPremium);
    
    // Initialize app
    checkLoginStatus();
  </script>
<script type="module">
  import { initializeApp } from "https://www.gstatic.com/firebasejs/10.11.0/firebase-app.js";
  import { getAnalytics } from "https://www.gstatic.com/firebasejs/10.11.0/firebase-analytics.js";
  import { getFirestore, collection, addDoc } from "https://www.gstatic.com/firebasejs/10.11.0/firebase-firestore.js";
  
  // Firebase config
  const firebaseConfig = {
    apiKey: "AIzaSyAGn34SFu8EamVVXzpWNp4DvqzrtOIDAfU",
    authDomain: "vibly-9527f.firebaseapp.com",
    projectId: "vibly-9527f",
    storageBucket: "vibly-9527f.appspot.com",
    messagingSenderId: "3598702438",
    appId: "1:3598702438:web:b646e4a07973a1c54a9aa7",
    measurementId: "G-870X6MJRCX"
  };

  // Firebase app ja Firestore alustus
  const app = initializeApp(firebaseConfig);
  const analytics = getAnalytics(app);
  const db = getFirestore(app);

  // Tallennusfunktio
  async function savePostToFirebase(title, content) {
    try {
      await addDoc(collection(db, "posts"), {
        title: title,
        content: content,
        timestamp: Date.now()
      });
      alert("Tallennettu Firebaseen!");
    } catch (e) {
      console.error("Virhe tallennuksessa: ", e);
    }
  }

  // Asetetaan savePostToFirebase globaaliksi, jotta voi käyttää muualla
  window.savePostToFirebase = savePostToFirebase;
</script>
